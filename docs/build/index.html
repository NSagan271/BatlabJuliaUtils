<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BatlabJuliaUtils Documentation · BatlabJuliaUtils Documentation</title><meta name="title" content="BatlabJuliaUtils Documentation · BatlabJuliaUtils Documentation"/><meta property="og:title" content="BatlabJuliaUtils Documentation · BatlabJuliaUtils Documentation"/><meta property="twitter:title" content="BatlabJuliaUtils Documentation · BatlabJuliaUtils Documentation"/><meta name="description" content="Documentation for BatlabJuliaUtils Documentation."/><meta property="og:description" content="Documentation for BatlabJuliaUtils Documentation."/><meta property="twitter:description" content="Documentation for BatlabJuliaUtils Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>BatlabJuliaUtils Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>BatlabJuliaUtils Documentation</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Some-Julia-Notes"><span>Some Julia Notes</span></a></li><li><a class="tocitem" href="#Keyword-Arguments-(kwargs...-Notation)"><span>Keyword Arguments (<code>kwargs...</code>  Notation)</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Broadcasting-Across-an-Array"><span>Broadcasting Across an Array</span></a></li><li><a class="tocitem" href="#MethodErrors"><span><code>MethodError</code>s</span></a></li><li class="toplevel"><a class="tocitem" href="#Defaults.jl"><span>Defaults.jl</span></a></li><li class="toplevel"><a class="tocitem" href="#Plotting-Helpers"><span>Plotting Helpers</span></a></li><li class="toplevel"><a class="tocitem" href="#Time-Frequency-Helper-Functions"><span>Time-Frequency Helper Functions</span></a></li><li><a class="tocitem" href="#ColWiseFFTs"><span>ColWiseFFTs</span></a></li><li><a class="tocitem" href="#Convert-Data-Indices-to-Time-or-Frequency"><span>Convert Data Indices to Time or Frequency</span></a></li><li><a class="tocitem" href="#Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms"><span>Short-Time Fourier Transforms (STFTs) and Spectrograms</span></a></li><li class="toplevel"><a class="tocitem" href="#Read-Audio-Data"><span>Read Audio Data</span></a></li><li class="toplevel"><a class="tocitem" href="#Filters"><span>Filters</span></a></li><li class="toplevel"><a class="tocitem" href="#Signal-to-Noise-Ratio"><span>Signal-to-Noise Ratio</span></a></li><li class="toplevel"><a class="tocitem" href="#Chirp-Sequences"><span>Chirp Sequences</span></a></li><li class="toplevel"><a class="tocitem" href="#&quot;Melody&quot;"><span>&quot;Melody&quot;</span></a></li><li class="toplevel"><a class="tocitem" href="#Optimization"><span>Optimization</span></a></li><li class="toplevel"><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>BatlabJuliaUtils Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BatlabJuliaUtils Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BatlabJuliaUtils-Documentation"><a class="docs-heading-anchor" href="#BatlabJuliaUtils-Documentation">BatlabJuliaUtils Documentation</a><a id="BatlabJuliaUtils-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#BatlabJuliaUtils-Documentation" title="Permalink"></a></h1><ul><li><a href="#BatlabJuliaUtils-Documentation">BatlabJuliaUtils Documentation</a></li><li><a href="#Some-Julia-Notes">Some Julia Notes</a></li><li class="no-marker"><ul><li><a href="#Keyword-Arguments-(kwargs...-Notation)">Keyword Arguments (<code>kwargs...</code>  Notation)</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Broadcasting-Across-an-Array">Broadcasting Across an Array</a></li><li><a href="#MethodErrors"><code>MethodError</code>s</a></li></ul></li><li><a href="#Defaults.jl">Defaults.jl</a></li><li><a href="#Plotting-Helpers">Plotting Helpers</a></li><li><a href="#Time-Frequency-Helper-Functions">Time-Frequency Helper Functions</a></li><li class="no-marker"><ul><li><a href="#ColWiseFFTs">ColWiseFFTs</a></li><li><a href="#Convert-Data-Indices-to-Time-or-Frequency">Convert Data Indices to Time or Frequency</a></li><li><a href="#Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms">Short-Time Fourier Transforms (STFTs) and Spectrograms</a></li></ul></li><li><a href="#Read-Audio-Data">Read Audio Data</a></li><li><a href="#Filters">Filters</a></li><li><a href="#Signal-to-Noise-Ratio">Signal-to-Noise Ratio</a></li><li><a href="#Chirp-Sequences">Chirp Sequences</a></li><li><a href="#&quot;Melody&quot;">&quot;Melody&quot;</a></li><li><a href="#Optimization">Optimization</a></li><li><a href="#Miscellaneous">Miscellaneous</a></li></ul><h1 id="Some-Julia-Notes"><a class="docs-heading-anchor" href="#Some-Julia-Notes">Some Julia Notes</a><a id="Some-Julia-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Julia-Notes" title="Permalink"></a></h1><h2 id="Keyword-Arguments-(kwargs...-Notation)"><a class="docs-heading-anchor" href="#Keyword-Arguments-(kwargs...-Notation)">Keyword Arguments (<code>kwargs...</code>  Notation)</a><a id="Keyword-Arguments-(kwargs...-Notation)-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments-(kwargs...-Notation)" title="Permalink"></a></h2><p>If a function is as follows:</p><pre><code class="nohighlight hljs">function helloworld(a; kwargs)</code></pre><p>then you can pass in any keyword arguments you want, as follows:</p><pre><code class="nohighlight hljs">helloworld(2; b=3, c=&quot;hello&quot;);</code></pre><p>The use of these keyword arguments, when present, is described in the documentation.</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>As Julia has some issues with plotting in Jupyter notebooks, it&#39;s recommended to use the <a href="#Plotting-Helpers">Plotting Helpers</a> listed here. If you use one of the built-in Julia plot functions, you can pass in the output of <a href="#BatlabJuliaUtils.getplottingsettings"><code>getplottingsettings</code></a> as keyword arguments as follows:</p><pre><code class="nohighlight hljs">plot(x_data, y_data; getplottingsettings(&quot;x label&quot;, &quot;y label&quot;, &quot;my title&quot;)...);</code></pre><p>Otherwise, the plot will show up as tiny unless you pass in the keyword argument <code>html_output_format=:png</code>, and the axis labels may be cut off unless you pass in <code>left_margin=10Plots.mm</code> and <code>bottom_margin=10Plots.mm</code>.</p><p>Also, if some plotting function is not producing an output in a Jupyter notebook, make sure there is no semicolon at the end of the statement.</p><h2 id="Broadcasting-Across-an-Array"><a class="docs-heading-anchor" href="#Broadcasting-Across-an-Array">Broadcasting Across an Array</a><a id="Broadcasting-Across-an-Array-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-Across-an-Array" title="Permalink"></a></h2><p>To broadcast a one number-to-one number function across an array, you can add a dot (<code>.</code>) after the function name.</p><p>For instance, if you have complex array</p><pre><code class="nohighlight hljs">A = [3.0 + 4.0im, 5.0 + 2.3im, 3.4 + 0.9im];</code></pre><p>you can get the magnitude of each element by <code>abs.(A)</code>, which produces</p><pre><code class="nohighlight hljs">1×3 Matrix{Float64}:
 5.0  5.50364  3.5171</code></pre><h2 id="MethodErrors"><a class="docs-heading-anchor" href="#MethodErrors"><code>MethodError</code>s</a><a id="MethodErrors-1"></a><a class="docs-heading-anchor-permalink" href="#MethodErrors" title="Permalink"></a></h2><p>If a function throws a <code>MethodError: no method matching...</code>, where the function wants you to pass in a <code>Matrix</code> but you passed in a <code>Vector</code>, you can apply <a href="#BatlabJuliaUtils.vectortomatrix"><code>vectortomatrix</code></a> to the vector before passing it into the function. If you have the opposite problem, you can use <a href="#BatlabJuliaUtils.matrixtovector"><code>matrixtovector</code></a>.</p><p>If the function takes in a single number but you want to pass in an array instead, look at <a href="#Broadcasting-Across-an-Array">Broadcasting Across an Array</a>.</p><p>If the datatype (e.g., <code>Int</code>, <code>Real</code>, <code>Float64</code>, etc.) of the input data is wrong, you can cast them to the correct type:</p><ul><li>If <code>A</code> is an array of <code>Int</code>s, you can cast them to <code>Float64</code> using <code>Float64.(A)</code>, and cast them to <code>Real</code> using <code>Real.(A)</code>.</li><li>If <code>A</code> is an array of <code>Float64</code>s, you can cast them to <code>Int</code>s using <code>Int.(round.(A))</code> (you can replace <code>round</code> with <code>floor</code> or <code>ceil</code>, depending on how you want to round the numbers). If you omit the <code>round</code>, and <code>A</code> contains decimal numbers, then casting them to an <code>Int</code> will throw an <code>InexactError</code>.</li></ul><p>-If <code>A</code> is an array of complex numbers but you know that the imaginary part should be zero (e.g., taking the inverse FFT of an FFT of a real array), you can do <code>real.(A)</code> to take the real part.</p><h1 id="Defaults.jl"><a class="docs-heading-anchor" href="#Defaults.jl">Defaults.jl</a><a id="Defaults.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Defaults.jl" title="Permalink"></a></h1><p><code>BatlabUtils/src/Defaults.jl</code> stores default values for sampling frequencies (250 kHz for audio and 360 Hz for video), the speed of sound (344.69 m/s), default plot dimensions, and some algorithm parameters.</p><h1 id="Plotting-Helpers"><a class="docs-heading-anchor" href="#Plotting-Helpers">Plotting Helpers</a><a id="Plotting-Helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Helpers" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getplottingsettings" href="#BatlabJuliaUtils.getplottingsettings"><code>BatlabJuliaUtils.getplottingsettings</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getplottingsettings(xlabel::String, ylabel::String, title::String;
    kwargs...) -&gt; Dict{Symbol, Any}</code></pre><p>Builds a dictionary of keyword arguments to pass into any plotting function, populated with the provided labels and titles, default font sizes and plot dimensions, and any additional keyword arguments passed into the function.</p><p>Inputs:</p><ul><li><code>xlabel</code>: label of the x-axis.</li><li><code>ylabel</code>: label of the y-axis.</li><li><code>title</code>: plot title.</li><li><code>kwargs...</code>: you can pass in any other keyword arguments to specify plotting   parameters or override the defaults set here.</li></ul><p>Output:</p><ul><li><code>kwargs_with_defaults</code>: dictionary of plotting keyword arguments.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.myplot" href="#BatlabJuliaUtils.myplot"><code>BatlabJuliaUtils.myplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">myplot(args...; kwargs...)</code></pre><p>Mimics Julia&#39;s <code>plot</code> function, except with defaults from <code>getplottingsettings</code> passed in. You can pass in any arguments you would to the regular <code>plot</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.myplot!" href="#BatlabJuliaUtils.myplot!"><code>BatlabJuliaUtils.myplot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">myplot!(args...; kwargs...)</code></pre><p>Same as <code>myplot</code>, except adds to the last plot produced instead of making a new plot.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotmicdata" href="#BatlabJuliaUtils.plotmicdata"><code>BatlabJuliaUtils.plotmicdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmicdata(idxs::AbstractArray{Int}, y::AbstractArray; plot_idxs=idxs,
    kwargs...)</code></pre><p>Plot a time segment of audio data <code>y</code>, with milliseconds on the x-axis and voltage on the y-axis, and default plotting settings from <code>getplottingsettings</code>.</p><p>Inputs:</p><ul><li><code>idxs</code>: time indices of input audio data to plot.</li><li><code>y</code>: audio data, where each column is one microphone.</li><li><code>plot_idxs</code> (default: <code>idxs</code>): the x-axis labels of the plot will be   <code>audioindextoms.(plot_idxs)</code>. Use this parameter if the x-axis labels you   want don&#39;t match the value you passed in for <code>idxs</code>.</li><li><code>kwargs...</code>: you can pass in any additional keyword arguments to set plotting   parameters.</li></ul></div></section><section><div><pre><code class="language-julia hljs">plotmicdata(y::AbstractArray; plot_idxs=1:size(y, 1), kwargs...)</code></pre><p>Plot audio data, with milliseconds on the x-axis and voltage on the y-axis, and default plotting settings from <code>getplottingsettings</code>. Plots the full length of <code>y</code>.</p><p>Inputs:</p><ul><li><code>y</code>: audio data, where each column is one microphone.</li><li><code>plot_idxs</code> (default: <code>1, 2, 3,...</code>): the x-axis labels of the plot will be   <code>audioindextoms.(plot_idxs)</code>.</li><li><code>kwargs...</code>: you can pass in any additional keyword arguments to set plotting   parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotmicdata!" href="#BatlabJuliaUtils.plotmicdata!"><code>BatlabJuliaUtils.plotmicdata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmicdata!(idxs::AbstractArray{Int}, y::AbstractArray; plot_idxs=idxs,
    kwargs...)</code></pre><p>Same as <code>plotmicdata(idxs, y)</code>, except adds to the last plot produced instead of making a new plot.</p></div></section><section><div><pre><code class="language-julia hljs">plotmicdata!(y::AbstractArray; plot_idxs=1:size(y, 1), kwargs...)</code></pre><p>Same as <code>plotmicdata(y)</code>, except adds to the last plot produced instead of making a new plot.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotfftmag" href="#BatlabJuliaUtils.plotfftmag"><code>BatlabJuliaUtils.plotfftmag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotfftmag(idxs::AbstractArray{Int}, y::AbstractArray;
    fft_idxs=1:length(idxs), kwargs...)</code></pre><p>Plot the Fourier transform magnitude of a time segment of real-valued time-domain audio data <code>y</code>.</p><p>Inputs:</p><ul><li><code>idxs</code>: time indices of input audio data to take the Fourier transform of.</li><li><code>y</code>: time-domain audio data, where each column is one microphone.</li><li><code>fft_indices</code> (default: plot all indices): indices of the Fourier transform   to plot. Use this parameter if you only want to plot some frequencies.</li><li><code>kwargs...</code>: you can pass in any additional keyword arguments to set plotting   parameters.</li></ul></div></section><section><div><pre><code class="language-julia hljs">plotfftmag(y::AbstractArray; fft_idxs=1:size(y, 1), kwargs...)</code></pre><p>Plot the Fourier transform magnitude of real-value time-domain audio data <code>y</code>. Takes the Fourier transform of the full length of <code>y</code>.</p><p>Inputs:</p><ul><li><code>y</code>: time-domain audio data, where each column is one microphone.</li><li><code>fft_indices</code> (default: plot all indices): indices of the Fourier transform   to plot. Use this parameter if you only want to plot some frequencies.</li><li><code>kwargs...</code>: you can pass in any additional keyword arguments to set plotting   parameters.</li></ul></div></section></article><h1 id="Time-Frequency-Helper-Functions"><a class="docs-heading-anchor" href="#Time-Frequency-Helper-Functions">Time-Frequency Helper Functions</a><a id="Time-Frequency-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Frequency-Helper-Functions" title="Permalink"></a></h1><h2 id="ColWiseFFTs"><a class="docs-heading-anchor" href="#ColWiseFFTs">ColWiseFFTs</a><a id="ColWiseFFTs-1"></a><a class="docs-heading-anchor-permalink" href="#ColWiseFFTs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.colwisefft" href="#BatlabJuliaUtils.colwisefft"><code>BatlabJuliaUtils.colwisefft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colwisefft(A::AbstractArray) -&gt; Matrix{Complex}</code></pre><p>Applies the Fast fourier Transform (FFT) to each column of input matrix <code>A</code>. <code>A</code> can also be a vector, in which case it is first transformed into a one-col matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.colwiseifft" href="#BatlabJuliaUtils.colwiseifft"><code>BatlabJuliaUtils.colwiseifft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colwiseifft(A::AbstractArray) -&gt; Matrix{Complex}</code></pre><p>Applies the Inverse FFT to each column of input matrix <code>A</code>. <code>A</code> can also be a vector, in which case it is first transformed into a one-col matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.rowwisefft" href="#BatlabJuliaUtils.rowwisefft"><code>BatlabJuliaUtils.rowwisefft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rowwisefft(A::Matrix) -&gt; Matrix{Complex}</code></pre><p>Applies the Fast fourier Transform (FFT) to each row of input matrix <code>A</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.rowwiseifft" href="#BatlabJuliaUtils.rowwiseifft"><code>BatlabJuliaUtils.rowwiseifft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rowwiseifft(A::Matrix) -&gt; Matrix{Complex}</code></pre><p>Applies the Inverse FFT to each row of input matrix <code>A</code>.</p></div></section></article><h2 id="Convert-Data-Indices-to-Time-or-Frequency"><a class="docs-heading-anchor" href="#Convert-Data-Indices-to-Time-or-Frequency">Convert Data Indices to Time or Frequency</a><a id="Convert-Data-Indices-to-Time-or-Frequency-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-Data-Indices-to-Time-or-Frequency" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.audioindextosec" href="#BatlabJuliaUtils.audioindextosec"><code>BatlabJuliaUtils.audioindextosec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">audioindextosec(index::Int; fs=250 kHz) -&gt; Real</code></pre><p>Given an index of the audio data, calculate the number of seconds since the beginning of the audio data.</p><p>Inputs:</p><ul><li><code>index</code>: index of audio data</li><li><code>fs</code>: sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li>Seconds since the beginning of the audio data</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.audioindextoms" href="#BatlabJuliaUtils.audioindextoms"><code>BatlabJuliaUtils.audioindextoms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">audioindextoms(index::Int; fs=250 kHz) -&gt; Real</code></pre><p>Given an index of the audio data, calculate the number of milliseconds since the beginning of the audio data.</p><p>Inputs:</p><ul><li><code>index</code>: index of audio data</li><li><code>fs</code>: sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li>Milliseconds since the beginning of the audio data</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.fftindextofrequency" href="#BatlabJuliaUtils.fftindextofrequency"><code>BatlabJuliaUtils.fftindextofrequency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fftindextofrequency(index::Int, N_fft::Int; fs=250 kHz) -&gt; Real</code></pre><p>Given an index of an Discrete Fourier Transform taken on a segment of audio datal determine what frequency (in Hz) it corresponds to.</p><p>Inputs:</p><ul><li><code>index</code>: index of the Fourier Transform.</li><li><code>N_fft</code>: length of the Fourier Transform, in samples.</li><li><code>fs</code>: sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li>Frequency, in Hz, of the specified Fourier Transform index</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getfftfrequencies" href="#BatlabJuliaUtils.getfftfrequencies"><code>BatlabJuliaUtils.getfftfrequencies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getfftfrequencies(N_fft::Int; fs=250 kHz) -&gt; Array{Real}</code></pre><p>Return an array of length <code>N_fft</code>, where each element is the frequency, in Hz, of the corresponding index of a length-<code>N_fft</code> Fourier Transform of a segment of audio data.</p><p>Inputs:</p><ul><li><code>N_fft</code>: length of the Fourier Transform, in samples.</li><li><code>fs</code>: sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.videoindextosec" href="#BatlabJuliaUtils.videoindextosec"><code>BatlabJuliaUtils.videoindextosec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">videoindextosec(idx_video::Int, L_video::Int; fs_video=360) -&gt; Real</code></pre><p>Given an index of the video data, return the number of seconds since the start of the audio data.</p><p>The video and audio data are synchronized such that the end of the video data is simultaneous with the 8-second mark of the audio data.</p><p>Inputs:</p><ul><li><code>idx_video</code>: index of the video data.</li><li><code>L_video</code>: length, in frames, of the video data.</li><li><code>fs_video</code>: sampling rate of the video data, in Hertz. Default set in    Defaults.jl.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.sectovideoindex" href="#BatlabJuliaUtils.sectovideoindex"><code>BatlabJuliaUtils.sectovideoindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sectovideoindex(time_audio::Number, L_video::Int; fs_video=360) -&gt; Int</code></pre><p>Given a time (since the start of the audio data) in seconds, calculate the index of the closest video frame.</p><p>The video and audio data are synchronized such that the end of the video data is simultaneous with the 8-second mark of the audio data.</p><p>Inputs:</p><ul><li><code>time_audio</code>: time, in seconds, since the start of the audio data.</li><li><code>L_video</code>: length, in frames, of the video data.</li><li><code>fs_video</code>: sampling rate of the video data, in hertz. Default set in    Defaults.jl.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getvideoslicefromtimes" href="#BatlabJuliaUtils.getvideoslicefromtimes"><code>BatlabJuliaUtils.getvideoslicefromtimes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getvideoslicefromtimes(location_data::Matrix{Real}, t1::Real,
    t2::Real, fs_video=360) -&gt; UnitRange{Int}, Matrix{Real}</code></pre><p>Returns the video data corresponding to time interval <code>[t1, t2]</code> of the audio data, where <code>t1</code> and <code>t2</code> are in seconds.</p><p>The two datasets are synchronized as follows: the end of the video data coincides with the 8-second mark of the audio data.</p><p>Inputs:</p><ul><li><code>location_data</code>: full centroid data, where the columns represent coordinates   (x, y, z).</li><li><code>t1</code>: start time (inclusive) of interval, in seconds since the onset of the   audio data.</li><li><code>t2</code>: end time (inclusive) of interval, in seconds since the onset of the   audio data.</li><li><code>fs_video</code> (default set in <code>Defaults.jl</code>): sampling frequency of the centroid   data, in Hertz.</li></ul><p>Outputs:</p><ul><li><code>slice_idxs</code>: indices of the audio data corresponding to the <code>[t1, t2]</code> slice   taken.</li><li><code>centroid_slice</code>: centroid data in the interval <code>[t1, t2]</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getvideodataslicefromaudioindices" href="#BatlabJuliaUtils.getvideodataslicefromaudioindices"><code>BatlabJuliaUtils.getvideodataslicefromaudioindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getvideodataslicefromaudioindices(location_data::Matrix{Real},
    t1_idx::Real, t2_idx::Real, fs_video=360, FS=250k) 
                                    -&gt; UnitRange{Int}, Matrix{Real}</code></pre><p>Same as <code>getvideoslicefromtimes</code>, but takes audio data indices in lieu of times.</p><p>Inputs:</p><ul><li><code>location_data</code>: full centroid data, where the columns represent coordinates   (x, y, z).</li><li><code>t1_idx</code>: index of the audio data (inclusive) at which to start the centroid   data slice.</li><li><code>t2_idx</code>: index of the audio data (inclusive) at which to end the centroid   data slice.</li><li><code>fs_video</code> (default set in <code>Defaults.jl</code>): sampling frequency of the centroid   data, in Hertz.</li><li><code>fs</code> (default set in <code>Defaults.jl</code>): sampling frequency of the audio   data, in Hertz.</li></ul><p>Outputs: see <code>getvideoslicefromtimes</code></p></div></section></article><h2 id="Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms"><a class="docs-heading-anchor" href="#Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms">Short-Time Fourier Transforms (STFTs) and Spectrograms</a><a id="Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms-1"></a><a class="docs-heading-anchor-permalink" href="#Short-Time-Fourier-Transforms-(STFTs)-and-Spectrograms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.STFTwithdefaults" href="#BatlabJuliaUtils.STFTwithdefaults"><code>BatlabJuliaUtils.STFTwithdefaults</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">STFTwithdefaults(y::AbstractArray, nfft=256,
    noverlap=Int(round(nfft/2)), window=hamming(nfft), zero_pad=true)
                                                    -&gt; Matrix{Complex}</code></pre><p>Wrapper around <code>DSP.Periodograms.stft</code>, which takes the short-time Fourier Transform (STFT) of a signal, with some reasonable default values set.</p><p>Inputs:</p><ul><li><code>y</code>: one-dimensional signal of which to take the STFT.</li><li><code>nfft</code> (default: 256): length of each window of the STFT.</li><li><code>noverlap</code> (default: <code>nfft/2</code>): overlap between adjacent STFT windows.</li><li><code>window</code> (default: Hamming): function multiplicatively applied to each   window to reduce spectral leakage.</li><li><code>zero_pad</code> (default: <code>true</code>): if set to <code>true</code>, zero-pad the beginning and end   of y with (<code>nfft-1</code>) zeros on either end.</li></ul><p>Output:</p><ul><li><code>Sy</code>: STFT of y. Matrix with (<code>nfft / 2 + 1</code>) rows, each corresponding to a   different frequency and <code>N</code> columns, where <code>N</code> is the number of time   windows taken.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotSTFTdb" href="#BatlabJuliaUtils.plotSTFTdb"><code>BatlabJuliaUtils.plotSTFTdb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotSTFTdb(Sy_db::Matrix; nfft=Int(2*floor(size(Sy_db, 1))), 
    noverlap=Int(round(nfft/2)), crange=50, fs=250 kHz,
    plotting_kwargs...)</code></pre><p>Plots spectrogram <code>Sy_db</code>, where <code>Sy_db</code> is in decibels (If <code>Sy</code> is the STFT of signal <code>y</code>, then <code>Sy_db</code> is 20 times <code>log10</code> of the magnitude squared of <code>Sy</code>).</p><p>Inputs:</p><ul><li><code>Sy_db</code>: STFT, in decibels.</li><li><code>nfft</code> (default: <code>2*(height of Sy_db - 1)</code>): length of each window of the STFT.    Used for axis labeling.</li><li><code>noverlap</code> (default: <code>nfft/2</code>): overlap between adjacent STFT windows. Used for   axis labeling.</li><li><code>window</code> (default: Hamming): function multiplicatively applied to each   window to reduce spectral leakage.</li><li><code>crange</code> (default: 50): the lowest value shown on the colorbar is the maximum   value of <code>Sy_db</code>, minus crange. All elements of <code>Sy_db</code> that are smaller than   this will show up in the spectrogram as this lowest value.</li><li><code>fs</code>: sampling frequency of the audio data, in Hertz. Default set in    Defaults.jl.</li><li><code>plotting_kwargs</code>: extra keyword arguments for plotting (passed into the   heatmap function).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotSTFT" href="#BatlabJuliaUtils.plotSTFT"><code>BatlabJuliaUtils.plotSTFT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotSTFT(Sy::Matrix{Complex}; nfft=Int(2*floor(size(Sy_db, 1))), 
    noverlap=Int(round(nfft/2)), crange=50, fs=250 kHz,
    plotting_kwargs...)</code></pre><p>Plots the spectrogram corresponding to STFT <code>Sy</code> (i.e., plots a heatmap of <code>Sy_db = 20*log10(|Sy|^2))</code>.</p><p>Inputs:</p><ul><li><code>Sy</code>: STFT, in decibels.</li><li>See <code>plotSTFTdb</code> for the rest of the arguments.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotSTFTtime" href="#BatlabJuliaUtils.plotSTFTtime"><code>BatlabJuliaUtils.plotSTFTtime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotSTFTtime(y::AbstractArray; nfft=256, noverlap=Int(round(nfft/2)),
    window=hamming(nfft), zero_pad=true, crange=50, fs=250 kHz,
    plotting_kwargs...)</code></pre><p>Takes the STFT of <code>y</code> and then plots the spectrogram using <code>plotSTFT</code>.</p><p>Inputs:</p><ul><li><code>y</code>: time-domain signal.</li><li><code>nfft</code>, <code>noverlap</code>, <code>window</code>, <code>zero_pad</code>: see <code>STFTwithdefaults</code>.</li><li><code>crange</code>, <code>fs</code>, <code>plotting_kwargs</code>: see <code>plotSTFTdb</code></li></ul></div></section></article><h1 id="Read-Audio-Data"><a class="docs-heading-anchor" href="#Read-Audio-Data">Read Audio Data</a><a id="Read-Audio-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Audio-Data" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.readmicdata" href="#BatlabJuliaUtils.readmicdata"><code>BatlabJuliaUtils.readmicdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readmicdata(mat_filename::String, n_channels=4) -&gt; Matrix{Real}</code></pre><p>Reads audio data from a MAT file into a matrix where each column represents a  different microphone.</p><p>These can be produced by running <code>matlab_utils/tdms_to_mat.m</code> on a TDMS file  with fields including  <code>Voltage_0</code>, <code>Voltage_1</code>, etc.</p><p>Inputs:</p><ul><li><code>mat_filename</code>: name of a <code>.mat</code> file with variables <code>Voltage_i</code>, where   microphone index i counts up from 0, each variable is a time-series array    of voltages for the corresponding microphone, and all arrays are of the    same length.</li><li><code>n_channels</code> (default 4): number of microphones</li></ul><p>Output:</p><ul><li><code>y</code>: N x K matrix, where N is the number of samples per microphone and K    is the number of microphones. Each column corresponds to a different   microphone.</li></ul></div></section></article><h1 id="Filters"><a class="docs-heading-anchor" href="#Filters">Filters</a><a id="Filters-1"></a><a class="docs-heading-anchor-permalink" href="#Filters" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.movingaveragefilter" href="#BatlabJuliaUtils.movingaveragefilter"><code>BatlabJuliaUtils.movingaveragefilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">movingaverage(x::AbstractArray, half_len::Int, stride=1)
                                                -&gt; Matrix{Real}</code></pre><p>Applies a symmetrical moving average filter of width <code>2*half_len + 1</code> to signal <code>x</code>. To make the output the same length as the input and avoid edge effects, the input is padded by duplicating the first and last elements each <code>half_len</code> times. The output is aligned with the input: i.e., if there is a large enough local maximum at index <code>i</code> of the input, there will also be a local maximum at the same index of the output.</p><p><code>x</code> may have multiple columns, where each column represents a different set of time-series data. In that case, the filter is applied separately to each column.</p><p>Inputs:</p><ul><li><code>x</code>: input vector, or matrix where each column is a different dataset (i.e.,   channel).</li><li><code>half_len</code>: determines the length of the filter, as described above.</li><li><code>stride</code> (default: 1): if <code>stride</code> is not 1, then the output is downsampled   by a factor of <code>stride</code>.</li></ul><p>Output:</p><ul><li><code>y</code>: result of applying a moving average filter to <code>x</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.maxfilter" href="#BatlabJuliaUtils.maxfilter"><code>BatlabJuliaUtils.maxfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxfilter(x::AbstractArray, half_len::Int) -&gt; Matrix{Real}</code></pre><p>Applies a maximum filter to the input:  <code>y[n] = maximum(x[n-half_len:n+half_len])</code>.</p><p>Input signal <code>x</code> may have multiple columns; each column represents a different set of time-series data.</p><p>Inputs:</p><ul><li><code>x</code>: input vector, or matrix where each column is a different dataset (i.e.,   channel).</li><li><code>half_len</code>: determines the length of the filter, as described above.</li></ul><p>Output:</p><ul><li><code>y</code>: output of the filter, as described above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.bandpassfilter" href="#BatlabJuliaUtils.bandpassfilter"><code>BatlabJuliaUtils.bandpassfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bandpassfilter(x::AbstractArray, min_Hz::Number, max_Hz::Number;
    fs=250 kHz) -&gt; AbstractArray{Real}</code></pre><p>Applies an ideal bandpass filter with cutoffs <code>min_Hz</code> and <code>max_Hz</code> to input signal <code>x</code>.</p><p>Input signal <code>x</code> may have multiple columns; each column represents a different set of time-series data</p><p>Inputs:</p><ul><li><code>x</code>: input vector, or matrix where each column is a different dataset (i.e.,   channel).</li><li><code>min_Hz</code>: lower cutoff of the filter.</li><li><code>max_Hz</code>: upper cutoff of the filter.</li><li><code>fs</code>: Sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li><code>y</code>: <code>x</code>, with frequencies below <code>min_Hz</code> or above <code>max_Hz</code> zeroed out.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.bandpassfilterFFT" href="#BatlabJuliaUtils.bandpassfilterFFT"><code>BatlabJuliaUtils.bandpassfilterFFT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bandpassfilterFFT(x_fft::AbstractArray, min_Hz::Number, max_Hz::Number;
    fs=250 kHz) -&gt; AbstractArray</code></pre><p>Same as <code>bandpassfilter</code>, except the input and output are in the frequency domain.</p><p>Inputs:</p><ul><li><code>x_fft</code>: input vector (or matrix) in the frequency domain.</li><li><code>min_Hz</code>: lower cutoff of the filter.</li><li><code>max_Hz</code>: upper cutoff of the filter.</li><li><code>fs</code>: Sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li><code>y_fft</code>: <code>x_fft</code>, with frequencies below <code>min_Hz</code> or above <code>max_Hz</code> zeroed   out.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.bandpassfilterspecgram" href="#BatlabJuliaUtils.bandpassfilterspecgram"><code>BatlabJuliaUtils.bandpassfilterspecgram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bandpassfilterspecgram(Sx::Matrix, min_Hz::Number, max_Hz::Number;
    nfft=2*(size(Sx, 1)-1), fs=FS) -&gt; AbstractArray</code></pre><p>Same as <code>bandpassfilter</code>, except the input and output are spectrograms.</p><p>Inputs:</p><ul><li><code>Sx</code>: input spectrogram.</li><li><code>min_Hz</code>: lower cutoff of the filter.</li><li><code>max_Hz</code>: upper cutoff of the filter.</li><li><code>nfft</code> (default: <code>2*(height of Sx-1)</code>): size of the window used to produce   the spectrogram.</li><li><code>fs</code>: Sampling frequency, in Hertz. Default set in Defaults.jl.</li></ul><p>Output:</p><ul><li><code>Sy</code>: <code>Sx</code>, with frequencies below <code>min_Hz</code> or above <code>max_Hz</code> zeroed out.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.circconv" href="#BatlabJuliaUtils.circconv"><code>BatlabJuliaUtils.circconv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circconv(x::AbstractArray, h::AbstractArray; real_output=true) -&gt; AbstractArray</code></pre><p>Perform circular convolution in the frequency domain: <code>y = iFFT(FFT(x) * FFT(h))</code>.</p><p>Inputs:</p><ul><li><code>x</code>, <code>h</code>: two vectors of the same dimension, or matrtices where each column   is a different channel of data.</li><li><code>real_output</code> (default: <code>true</code>): whether to take the real component of the   output before returning (<code>false</code> to leave the output a complex number).</li></ul><p>Output:</p><ul><li>circular convolution of x and y</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.deconvolve" href="#BatlabJuliaUtils.deconvolve"><code>BatlabJuliaUtils.deconvolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deconvolve(Y::AbstractArray, X::AbstractArray; fft_thresh=0.1) 
                                                -&gt; AbstractArray</code></pre><p>Perform deconvolution: i.e., given linear time-invariant system <code>Y</code> and input <code>X</code>, such that <code>Y</code> is <code>X</code> convolved with impulse response <code>H</code>, find <code>H</code> using Fourier transforms (<code>H = iFFT(FFT(Y) ./ FFT(X))</code>).</p><p>Optionally, zero out indices of <code>FFT(Y) ./ FFT(X)</code> where the magnitude of  <code>FFT(X)</code> is above some threshold, <code>fft_thresh</code>.</p><p><code>X</code> and <code>Y</code> must have the same dimensions. If they are matrices, deconvolution is applied separately to each column.</p><p>Inputs:</p><ul><li><code>Y</code>: system output; either a vector or a matrix where each column is a   different data channel.</li><li><code>X</code>: system input; same dimensions as <code>Y</code>.</li><li><code>fft_thresh</code> (default: 0): described above.</li></ul><p>Outputs:</p><ul><li><code>H</code>: estimated impulse response; same dimensions as <code>X</code> and <code>Y</code>.</li></ul></div></section></article><h1 id="Signal-to-Noise-Ratio"><a class="docs-heading-anchor" href="#Signal-to-Noise-Ratio">Signal-to-Noise Ratio</a><a id="Signal-to-Noise-Ratio-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-to-Noise-Ratio" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getnoisesampleidxs" href="#BatlabJuliaUtils.getnoisesampleidxs"><code>BatlabJuliaUtils.getnoisesampleidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getnoisesampleidxs(mic_data::AbstractArray; window_size=200)
                                                -&gt; UnitRange{Int}</code></pre><p>Given audio data, find the longest segment that is just noise.</p><p>First, the algorithm divides the data into segments of length <code>window_size</code>. The amplitude of a window is defined as the maximum deviation of <code>mic_data</code> from its mean (over the window). The maximum noise level is set at twice the minimum amplitude of any window. The algorithm finds the indices of the longest section of <code>mic_data</code> where no window has an amplitude above the noise level.</p><p>Inputs:</p><ul><li><code>mic_data</code>: matrix of audio data, where each column is a different channel.</li><li><code>window_size</code>: length of the windows described above.</li></ul><p>Outputs:</p><ul><li><code>UnitRange</code> (i.e., the datatype of the object <code>1:10</code>) of the indices of the   longest segment of the data that is only noise.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.windowedenergy" href="#BatlabJuliaUtils.windowedenergy"><code>BatlabJuliaUtils.windowedenergy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">windowedenergy(x::AbstractArray, window_size::Int; window=hamming(nfft))
                                                        -&gt; Matrix{Real}</code></pre><p>Finds the energy over sliding windows of the signal <code>x</code>, where the windows have stride 1 (i.e., if the first window starts at index 1, the second window starts at index 2, etc.)</p><p>Inputs:</p><ul><li><code>x</code>: vector of data, or matrix where each column is a different channel of   data.</li><li><code>window_size</code> (default: 64): window length, in samples.</li><li><code>window</code> (default: <code>ones(window_size)</code>): vector to multiply each window by.   The default, <code>ones</code>, multiplies each element by 1. To emphasize the center   of long windows, you can use windows like <code>hamming(window_size)</code> from the   <code>DSP</code> package.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.estimatesnr" href="#BatlabJuliaUtils.estimatesnr"><code>BatlabJuliaUtils.estimatesnr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimatesnr(y::AbstractArray, noise_sample::AbstractArray, window_size=256,
    window=ones(window_size)) -&gt; Matrix{Real}</code></pre><p>Crude estimate of the signal-to-noise ratio of the input signal <code>y</code>. The signal and noise levels are computed by taking the energy over sliding windows (with stride 1) of <code>y</code> and <code>noise_sample</code>, respectively. The SNR is estimated as the signal level of each window, divided by the mean noise level.</p><p>Inputs:</p><ul><li><code>y</code>: input signal, which may be a vector, or a matrix where each column is a   different channel.</li><li><code>noise_sample</code>: sample of noise, with the same number of channels as <code>y</code>.</li><li><code>window_size</code> (default: 64): window length, in samples.</li><li><code>window</code> (default: <code>ones(window_size)</code>): vector to multiply each window by.   The default, <code>ones</code>, multiplies each element by 1. To emphasize the center   of long windows, you can use windows like <code>hamming(window_size)</code> from the   <code>DSP</code> package.</li></ul><p>Output:</p><ul><li><code>snr_est</code>: estimated SNR, in decibels (log scale, times 20) of every   timepoint in <code>y</code>.</li></ul></div></section></article><h1 id="Chirp-Sequences"><a class="docs-heading-anchor" href="#Chirp-Sequences">Chirp Sequences</a><a id="Chirp-Sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Chirp-Sequences" title="Permalink"></a></h1><p><strong>Terminology: Chirp Sequences</strong></p><p>A chirp sequence is defined as all microphone outputs that result from a single bat vocalization.</p><p>This is a somewhat overloaded term, which can mean one of two things:</p><ol><li>For a single microphone, a chirp and subsequent echos. We can call this a &quot;single-mic chirp sequence&quot;.</li><li>The chirp and subsequent echos, but for all microphones that picked up the chirp. We can call this a &quot;multi-mic chirp sequence&quot;.</li></ol><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.estimatebuzzphase" href="#BatlabJuliaUtils.estimatebuzzphase"><code>BatlabJuliaUtils.estimatebuzzphase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function estimatebuzzphase(snr::AbstractArray;
    buzz_phase_chirp_separation_ms=20) -&gt; Matrix{Int}</code></pre><p>Makes a very rudimentary estimate of chirp onsets, as heard by microphones, and then finds all times where chirp onsets are less than <code>buzz_phase_chirp_separation_ms</code> apart, for each microphone. It then prints out these time windows in descending order of length (these are the potential buzz phase times).</p><p>Note that can also classify some echos as chirp sequences, so expect there to be false positives.</p><p>Inputs:</p><ul><li><code>snr</code>: output of <code>estimatesnr</code>.</li><li><code>buzz_phase_chirp_separation_ms</code> (default: 20): maximum number of   milliseconds expected between onsets of consecutive buzz phase chirps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.ChirpSequence" href="#BatlabJuliaUtils.ChirpSequence"><code>BatlabJuliaUtils.ChirpSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ChirpSequence
    start_idx::Int
    length::Int
    vocalization_time_ms::Real
    snr_data::Vector{Real}
    mic_data::Vector{Real}
    mic_num::Int
end</code></pre><p>Datastructure to store individual chirp sequences (for a single microphone).</p><p>Fields:</p><ul><li><code>start_idx</code>: start of the chirp, in number of samples since the beginning of   the audio data that this chirp sequence comes from (i.e., the MAT data that   was initially read in).</li><li><code>length</code>: length, in audio samples, of the chirp sequence.</li><li><code>vocalization_time_ms</code>: time (since the beginning of the audio data) that the   bat made the vocalization. Estimated using the centroid data.</li><li><code>snr_data</code>: vector of estimated SNR values over the duration of the chirp   sequence. Produced by <code>estimatesnr</code>.</li><li><code>mic_data</code>: audio data for the given microphone, over the duration of the   chirp sequence.</li><li><code>mic_num</code>: which microphone (from 1 to 4) the data corresponds to.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getboundsfromboxes" href="#BatlabJuliaUtils.getboundsfromboxes"><code>BatlabJuliaUtils.getboundsfromboxes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getboundsfromboxes(boxes::AbstractArray;
    filter_fn=(start_idx, stop_idx) -&gt; true) -&gt; Matrix{Int}</code></pre><p>Given bitarray <code>boxes</code> (as a column vector), return a matrix where the first column is the start indices of the sections where <code>boxes==1</code>, and the second column is the end indices of those sections.</p><p>Optionally, only keep boxes where filter_fn returns true.</p><p>Inputs:</p><ul><li><code>boxes</code>: one-dimensional bitarray.</li><li><code>filter_fn</code> (default: always return <code>true</code>): function that takes in the start   and end indices of a region where <code>boxes==1</code> and returns <code>false</code> for boxes   to discard.</li></ul><p>Output:</p><ul><li><code>bounds</code>: two-column matrix, as described above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.findhighsnrregions" href="#BatlabJuliaUtils.findhighsnrregions"><code>BatlabJuliaUtils.findhighsnrregions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findhighsnrregions(snr::AbstractArray, signal_thresh::Number,
    min_peak_thresh::Number, maxfilter_length::Int;
    snr_drop_thresh=20, peak_snr_thresh_radius=1500)-&gt; BitArray</code></pre><p>Given the estimated SNR of the audio data (from the function <code>estimatesnr</code>), determine which regions are likely to contain chirp sequences, as follows:</p><ol><li>Apply a <code>maxfilter</code> to the <code>snr</code> array: this helps us find contiguous  regions with high SNR.</li><li>Find all sections where the maxfiltered SNR is above <code>signal_thresh</code>.</li><li>Of those sections, keep the ones where, at some point, the SNR goes above  another, higher threshold.</li></ol><p>The threshold in step 3 above is set as follows:</p><ol><li>We look around in a range of <code>peak_snr_thresh_radius</code> around the &quot;signal  region&quot; and we find the maximum SNR present in that range.</li><li>We require that the peak SNR of the &quot;signal region&quot; be at most  <code>snr_drop_thresh</code> dB lower than that maximum value.</li><li>We also require that the peak SNR be no lower than <code>min_peak_thresh</code>.</li></ol><p>Inputs:</p><ul><li><code>snr</code>: estimated SNR of the audio data, produced by <code>estimatesnr</code>, either the   full matrix or one column.</li><li><code>signal_thresh</code>, <code>min_peak_thresh</code>, <code>snr_drop_thresh</code>,   <code>peak_snr_thresh_radius</code>: thresholds, descsribed above.</li><li><code>maxfilter_length</code>: half-length, in samples, of the maximum filter.</li></ul><p>Output:</p><ul><li><code>high_snr_locations</code>: bitarray that is <code>1</code> in regions that likely contain   chirp sequences.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.findhighsnrregionidxs" href="#BatlabJuliaUtils.findhighsnrregionidxs"><code>BatlabJuliaUtils.findhighsnrregionidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findroughchirpsequencebounds(snr::AbstractArray, mic::Int,
    signal_thresh::Number, peak_thresh::Number, maxfilter_length::Int)
                                                        -&gt; Matrix{Int}</code></pre><p>For a single microphone/channel, converts the output of <code>findhighsnrregions</code> to a two-column matrix, where the first column is the start index of each presumed chirp sequence.</p><p>Inputs:</p><ul><li><code>snr</code>: estimated SNR of the audio data, produced by <code>estimatesnr</code> (full    matrix).</li><li><code>signal_thresh</code>, <code>peak_thresh</code>, <code>snr_drop_thresh</code>,   <code>peak_snr_thresh_radius</code>: thresholds, described in <code>findhighsnrregions</code>.</li><li><code>maxfilter_length</code>: half-length, in samples, of the maximum filter.</li></ul><p>Output: described above.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.adjusthighsnridxs" href="#BatlabJuliaUtils.adjusthighsnridxs"><code>BatlabJuliaUtils.adjusthighsnridxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjusthighsnridxs(snr::AbstractArray, mic::Int,
    rough_bounds::Vector{Int}, max_end_idx::Int; tail_snr_thresh::Real,
    max_seq_len=MAX_SEQUENCE_LENGTH, maxfilter_seq_end=50) -&gt; Vector{Int}</code></pre><p>Given rough bounds for a single chirp sequence (one row of the output of <code>findhighsnrregionidxs</code>), adjust the end index to ensure that the chirp sequence isn&#39;t cut off early.</p><p>The process is similar to <code>findhighsnrregions</code>, but with more lenient thresholds.</p><ol><li>Apply a <code>maxfilter</code> to the <code>snr</code> array, with a filter size that is ideally  longer than the one used for <code>findhighsnrregionidxs</code>.</li><li>Find the first index of the maxfiltered SNRs that goes below  <code>tail_snr_thresh</code>, a threshold lower than the one used for  <code>findhighsnrregionidxs</code>, and sets the end index of the chirp  sequence to this. If this index is beyond <code>max_end_idx</code>, then the end of  the chirp sequence is set to <code>max_end_idx</code>.</li></ol><p>Inputs:</p><ul><li><code>snr</code>: estimated SNR of the audio data, produced by <code>estimatesnr</code> (full    matrix).</li><li><code>mic</code>: microphone number, from 1 to 4.</li><li><code>rough_bounds</code>: row of the matrix produced by <code>findhighsnrregionidxs</code>.</li><li><code>max_end_idx</code>: the start of the next chirp sequence, or the end of the signal       if this is the last chirp sequence for a particular microphone.</li><li><code>tail_snr_thresh</code>: described above.</li><li><code>max_seq_len</code> maximum length of the chirp sequence. Default set in   <code>Defaults.jl</code>.</li><li><code>maxfilter_length</code> (default: 50): half-length, in samples, of the maximum   filter.</li></ul><p>Output:</p><ul><li><code>refined_bounds</code>: two-element vector, where the first element is the start   of the chirp sequence (unchanged), and the second element is the </li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getvocalizationtimems" href="#BatlabJuliaUtils.getvocalizationtimems"><code>BatlabJuliaUtils.getvocalizationtimems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getvocalizationtimems(chirp_start_index::Int, mic::Int,
    location_data::Matrix{Real}, mic_positions::Matrix{Real}; 
    buffer_time_ms=100, fs_video=360,
    interp_type=QuadraticInterpolation) -&gt; Real</code></pre><p>Given the index of the audio data at which a chirp sequence starts, estimate the time that the bat made a vocalization, in milliseconds since the start of the audio data.</p><p>This is achieved by taking a slice of the centroid data of radius <code>buffer_time_ms</code> around the time the chirp reached the microphone, performing quadratic interpolation of the centroid data over that slice, and solving for <code>t</code> in</p><p><code>distance_from_mic(t) = speed_of_sound * (time_chirp_reached_mic - t)</code></p><p>to get the vocalization time.</p><p>This function returns <code>NaN</code> (not a number) if there isn&#39;t sufficient location data to determine the vocalization time.</p><p>Inputs:</p><ul><li><code>chirp_start_index</code>: index of the audio data that the chirp sequence started.</li><li><code>mic</code>: microphone that heard the chirp sequence.</li><li><code>location_data</code>: full centroid data, where the columns represent coordinates   (x, y, z).</li><li><code>mic_positions</code>: matrix of microphone positions, where each row is a   different microphone and the columns represent coordinates (x, y, z).</li><li><code>buffer_time_ms</code> (default: 100): radius, in milliseconds, of the slice of   centroid data to examine.</li><li><code>fs_video</code> (default set in <code>Defaults.jl</code>): sampling rate of the centroid   data.</li><li><code>interp_type</code> (default: <code>QuadraticInterpolation</code>): type of interpolation   (from the package <code>DataInterpolations</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.groupchirpsequencesbystarttime" href="#BatlabJuliaUtils.groupchirpsequencesbystarttime"><code>BatlabJuliaUtils.groupchirpsequencesbystarttime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">groupchirpsequencesbystarttime(
    chirp_sequence_bounds_per_mic::AbstractArray{Matrix{Int}},
    snr::Matrix{Real}, y::Matrix{Real}, location_data::Matrix{Real},
    mic_locations::Matrix{Real}, single_chirp_snr_thresh=100,
    vocalization_start_tolerance_ms=1.5, any_mic_snr_thresh=45) 
                    -&gt; Vector{Dict{Int, ChirpSequence}}, Vector{Real}</code></pre><p>Given start and end indices of chirp sequences, for all microphones, determine which chirp sequences came from the same initial chirp. Only keep chirp sequences arising from vocalizations heard by at least two microphones.</p><p>Inputs:</p><ul><li><code>chirp_sequence_bounds_per_mic</code>: array of <code>[chirp sequence indices for mic 1,   ..., chirp sequence indices for mic 4]</code>. &quot;Chirp sequence indices for   mic i&quot; refers to a two-column matrix where the first column is the start indices   of each chirp sequence and the second column is the corresponding end   indices.</li><li><code>snr</code>: estimated SNR of the audio data, produced by <code>estimatesnr</code>.</li><li><code>y</code>: matrix of audio data, where each column is a different microphone.</li><li><code>location_data</code>: full centroid data, where the columns represent coordinates   (x, y, z).</li><li><code>mic_positions</code>: matrix of microphone positions, where each row is a   different microphone and the columns represent coordinates (x, y, z).</li><li><code>single_mic_snr_thresh</code> (default: 100): if a chirp sequence only has data   from one microphone, still store the chirp sequence if it has a SNR over   this value.</li><li><code>any_mic_snr_thresh</code> (default: 45): if none of the microphones have an SNR   above this threshold, then we probably picked up an echo instead of a chirp,   which should be disregarded.</li><li><code>vocalization_start_tolerance_ms</code> (default: 1.5): if the estimated   vocalization time for two chirp sequences (for different microphones) is   within <code>vocalization_start_tolerance_ms</code> milliseconds, then they are   considered to be from the same vocalization.</li></ul><p>Output:</p><ul><li><p><code>chirp_sequences</code>: example form   <code>[{1 -&gt; ChirpSequences(...), 2 -&gt; ChirpSequence(...)},    {2-&gt; ChirpSequence(...), 4 -&gt; ChirpSequence(...), 3 -&gt; ChirpSequence(...)},    ...   ]</code>   Each element of the <code>chirp_sequences</code> vector corresponds to all chirp   sequences arising from a single vocalization. This is represented by a   dictionary mapping microphone number to <code>ChirpSequence</code> structure.</p></li><li><p><code>vocalization_times</code>: vector, where each element is the estimated vocalization   time for the corresponding chirp sequence.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotchirpsequence" href="#BatlabJuliaUtils.plotchirpsequence"><code>BatlabJuliaUtils.plotchirpsequence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function plotchirpsequence(chirp_seq::Dict{Int, ChirpSequence};
    plot_separate=false, plot_spectrogram=false, same_length=true,
    n_cols=true)</code></pre><p>Plots a chirp sequence on one of three formats:</p><ol><li>If <code>plot_separate</code> and <code>plot_spectrogram</code> are both <code>false</code>, it plots the  data from all microphones in the same plot.</li><li>If <code>plot_spectrogram</code> is <code>true</code>, then it plots the spectrogram of the  chirp sequence for each microphone (in separate plots).</li><li>Otherwise, if <code>plot_separate</code> is <code>true</code>, it plots the time-domain  waveforms for each microphone (in separate plots).</li></ol><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: dictionary mapping microphone number to a   <code>ChirpSequence</code> object.</li><li><code>plot_separate</code>, <code>plot_spectrogram</code>: descibed above.</li><li><code>same_length</code> (default: true): zero-pad shorter chirp sequences at the end   so that all chirp sequences are the same length. Only relevant for   <code>plot_separate</code> or <code>plot_spectrogram</code>.</li><li><code>n_cols (default: 2)</code>: number of plots per row.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotchirpsequenceboxes" href="#BatlabJuliaUtils.plotchirpsequenceboxes"><code>BatlabJuliaUtils.plotchirpsequenceboxes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotchirpsequenceboxes(start_ms::Real, stop_ms::Real,
    vocalization_times::Array, chirp_sequences::Array{Dict{Int, ChirpSequence}},
    y::Matrix{Real}, mics=1:size(y, 2))</code></pre><p>Plots audio data (specified by matrix <code>y</code>) from <code>start_ms</code> to <code>stop_ms</code> milliseconds, with boxes around all chirp sequences in that interval. Estimated vocalization times are written above all boxes.</p><p>Inputs:</p><ul><li><code>start_ms</code>: start time of the plot, in milliseconds.</li><li><code>stop_ms</code>: stop time of the plot, in milliseconds.</li><li><code>vocalization_times</code>: list of vocalization times output by   <code>groupchirpsequencesbystarttime</code>.</li><li><code>chirp_sequences</code>: list of mappings from microphone to <code>ChirpSequence</code> object   produced by <code>groupchirpsequencesbystarttime</code>.</li><li><code>y</code>: matrix of microphone data, where each column is a different microphone.</li><li><code>mics</code> (default: all): microphones for which to plot chirp sequences.</li></ul></div></section></article><h1 id="&quot;Melody&quot;"><a class="docs-heading-anchor" href="#&quot;Melody&quot;">&quot;Melody&quot;</a><a id="&quot;Melody&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Melody&quot;" title="Permalink"></a></h1><p>We define the &quot;melody&quot; of the vocalization as the fundamental harmonic of the chirp.</p><p>This section contains documentation for estimating the melody, as well as some basic methods for separating chirps from echos.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.findmelody" href="#BatlabJuliaUtils.findmelody"><code>BatlabJuliaUtils.findmelody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmelody(chirp_seq_single_mic::ChirpSequence, peak_snr_thresh::Real;
    find_highest_snr_in_first_ms=1, nfft=256,
    bandpass_filter=(20_000, 100_000), maximum_melody_slope=5)
                                                        -&gt; Vector{Int}</code></pre><p>Given a chirp sequence (for a single microphone), estimate the &quot;melody&quot; (i.e., the fundamental harmonic) of the vocalization using the spectrogram.</p><p>The melody is traced as follows:</p><ol><li>Find the time in the first <code>find_highest_snr_in_first_ms</code> milliseconds  of the chirp with the highest SNR, and find the melody of the chirp at that  point (here, the SNR is hopefully high enough to accurately estimate the  melody).</li><li>Work backwards until the beginning of the chirp, at each index looking for  the strongest frequency within some small range of the last frequency  found. This range is determined by the parameter <code>maximum_melody_slope</code>.</li><li>Repeat, but this time work towards the end of the chirp. To avoid picking up  echos, enforce that, once the slope of the melody (with respect to time)  becomes negative, it can never become positive.</li></ol><p>After tracing the melody, we need to see if we found the fundamental harmonic or some higher harmonic. This is done by taking the loudest part of the melody and dividing the frequency by 2, 3, etc. until we go below 20 kHz. The fundamental harmonic is the lowest such frequency with power at most <code>melody_drop_thresh_db</code> below the loudest harmonic.</p><p>The melody is computed in terms of Fourier transform indices. To find the  melody in Hertz, use the <code>fftindextofrequency</code> function or use  <code>findmelodyhertz</code> instead.</p><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>peak_snr_thresh</code>: threshold previously set for the peak SNR of a chirp   sequence.</li><li><code>find_highest_snr_in_first_ms</code> (default: 1): described in step 1 above.</li><li><code>nfft</code> (default: 256): window size for computing the spectrogram.</li><li><code>bandpass_filter</code> (default: <code>(20_000, 100_000)</code>): before computing the melody,   a band-pass filter is applied to the spectrogram. <code>bandpass_filter</code> is a   tuple of the (lower cutoff, upper cutoff), in Hertz.</li><li><code>maximum_melody_slope</code> (default: 5): maximum amount, in Fourier transform    indices, that that the melody is allowed to change from one index to the    next.</li><li><code>melody_drop_thresh_db</code> (default: 20): used to find the fundamental harmonic; described above.</li></ul><p>Output:</p><ul><li><code>melody</code>: described above.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.findmelodyhertz" href="#BatlabJuliaUtils.findmelodyhertz"><code>BatlabJuliaUtils.findmelodyhertz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findmelodyhertz(chirp_seq_single_mic::ChirpSequence, peak_snr_thresh::Real;
    nfft=256, melody_keyword_arguments...) -&gt; Vector{Real}</code></pre><p>Same as <code>findmelody</code>, but converts the result to Hertz.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getharmonic" href="#BatlabJuliaUtils.getharmonic"><code>BatlabJuliaUtils.getharmonic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getharmonic(chirp_seq_single_mic::ChirpSequence, melody::AbstractArray{Int},
    harmonic_num::Int; nfft=256, band_size=2) -&gt; Vector{Int}</code></pre><p>Given the output of <code>findmelody</code> for <code>chirp_seq_single_mic</code>, find the harmonic given by <code>harmonic_num</code>. This is done by searching for the strongest frequencies in a region of radius <code>band_size</code> around <code>harmonic_num</code> times the melody.</p><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>melody</code>: output of <code>findmelody</code>.</li><li><code>harmonic_num</code>: which harmonic to find (e.g., 2, 3, etc.)</li><li><code>nfft</code> (default: 256): window size for computing the spectrogram.</li><li><code>band_size</code> (default: 2): described above.</li></ul><p>Outputs:</p><ul><li><code>harmonic</code>: array that contains the estimated harmonic, in Fourier transform   indices.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.smoothmelody" href="#BatlabJuliaUtils.smoothmelody"><code>BatlabJuliaUtils.smoothmelody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">smoothmelody(melody::AbstractArray{Int}; filter_size=64)</code></pre><p>Smooths a melody by produced by <code>findmelody</code> by applying a moving average filter.</p><p>Inputs:</p><ul><li><code>melody</code>: output of <code>findmelody</code>.</li><li><code>filter_size</code> (default: 64): kernel size of the moving average filter.</li></ul><p>Output:</p><ul><li><code>melody</code>, with a moving average filter applied, with each element rounded to the nearest integer.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.estimatechirpbounds" href="#BatlabJuliaUtils.estimatechirpbounds"><code>BatlabJuliaUtils.estimatechirpbounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    estimatechirpbounds(chirp_seq_single_mic::ChirpSequence,
    melody::Vector{Int}, peak_snr_thresh::Real; nfft=256,
    bandpass_filter=(20_000, 100_000),melody_drop_thresh_db=20, melody_thresh_db_low=-20,moving_avg_size=10) -&gt; Int</code></pre><p>Given a chirp sequence object (from a single mic) and the melody estimated by <code>findmelody</code>, estimate the end index of the chirp (i.e., separate the chirp from the echos) as follows:</p><ol><li>Find the point where the melody is the strongest.</li><li>Find the first index, after this point, where the melody strength drops over  <code>melody_drop_thresh_db</code> decibels from its peak value (if this cutoff value  is below <code>melody_thresh_db_low</code>, we instead find where the melody strength  goes below <code>melody_thresh_db_low</code>).<ul><li>If the melody strength never drops below this threshold, then just return   the last index of the chirp sequence.</li></ul></li><li>Apply a moving average filter to the melody strength.</li><li>Apply the following heuristic:<ul><li>The end of the chirp is the first local minimum of the melody strength after the index from step 2, or the first time the melody strength dips below <code>melody_thresh_db_low</code>, whichever comes first.</li><li>If neither event happens, return the last index of the chirp sequence.</li></ul></li></ol><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>melody</code>: result of <code>findmelody</code>.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>use_second_harmonic_if_melody_starts_below</code> (default: 35,000): if the   beginning of the melody, in Hertz, is below this number, then the end   probably goes below the range of the microphone. So, we want to check if   using the second harmonic leads to a longer chip and, if so, use the second   harmonic to estimate the chirp onset and offset.</li><li><code>nfft</code> (default: 256): window size for computing the spectrogram.</li><li><code>bandpass_filter</code> (default: <code>(20_000, 100_000)</code>): before computing the melody,   a band-pass filter is applied to the spectrogram. <code>bandpass_filter</code> is a   tuple of the (lower cutoff, upper cutoff), in Hertz.</li><li><code>melody_drop_thresh_db</code>, <code>melody_thresh_db_low</code> (defaults: 20, -20):   described in step 2 above.</li><li><code>melody_drop_thresh_db_start</code> (default: 35): the start index of the chirp is   computed as the first index where the melody strength is at most this amount   lower than its maximum value. </li><li><code>moving_avg_size</code>: radius of the moving average filter from step 4 above.</li></ul><p>Output:</p><ul><li><code>chirp_start_index</code>: estimated start index of the chirp, in indices since the   start of the chirp sequence.</li><li><code>chirp_end_index</code>: estimated end index of the chirp, in indices since the   start of the chirp sequence.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getchirpstartandendindices" href="#BatlabJuliaUtils.getchirpstartandendindices"><code>BatlabJuliaUtils.getchirpstartandendindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getchirpstartandendindices(
    chirp_sequence_all_mics::Dict{Int, ChirpSequence}, peak_snr_thresh::Real;
    chirp_kwargs...) -&gt; Dict{Int, Int}, Dict{Int, Int}</code></pre><p>Given a dictionary mapping microphones to <code>ChirpSequence</code> objects, run <code>findmelody</code> and <code>estimatechirpbounds</code> for each <code>ChirpSequence</code> and return two dictionaries mapping microphones to chirp start indices and chirp end indices, respectively. Indices are calculated in samples since the start of the chirp sequence (i.e., since the beginning of the <code>mic_data</code> array of the <code>ChirpSequence</code> object).</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>chirp_kwargs</code>: you can additionally pass in any keyword arguments for</li></ul><p><code>findmelody</code> and/or <code>estimate_chirp_bounds</code>.</p><p>Outputs:</p><ul><li><code>chirp_starts</code>: dictionary mapping microphone indices to their respective   chirp start indices (in samples since the start of the chirp sequence).</li><li><code>chirp_ends</code>: dictionary mapping microphone indices to their respective   chirp end indices (in samples since the start of the chirp sequence).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotmelody" href="#BatlabJuliaUtils.plotmelody"><code>BatlabJuliaUtils.plotmelody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmelody(chirp_seq_single_mic::ChirpSequence, melody::Vector{Int},
    chirp_end=nothing; nfft=256, bandpass_filter=(20_000, 100_000),
    melody_color=&quot;blue&quot;, end_color=&quot;cyan&quot;)</code></pre><p>Plots the melody estimated by <code>findmelody</code>, overlayed on the spectrogram of the chirp sequence. Optionally, plot a vertical line at the estimated end of the chirp sequence.</p><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>melody</code>: result of <code>findmelody</code>.</li><li><code>chirp_end</code> (default: <code>nothing</code>): optionally, result of <code>estimatechirpend</code>.   If <code>chirp_end</code> is nothing, then no vertical line is plotted.</li><li><code>nfft</code> (default: 256): window size for computing the spectrogram.</li><li><code>bandpass_filter</code> (default: <code>(20_000, 100_000)</code>): before computing the melody,   a band-pass filter is applied to the spectrogram. <code>bandpass_filter</code> is a   tuple of the (lower cutoff, upper cutoff), in Hertz.</li><li>melody_color (default: &quot;blue&quot;): color used to plot the melody.</li><li>end_color (default: &quot;cyan&quot;): color used to plot the vertical line at the end   of the chirp sequence.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotmelodydb" href="#BatlabJuliaUtils.plotmelodydb"><code>BatlabJuliaUtils.plotmelodydb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotmelodydb(chirp_seq_single_mic::ChirpSequence, melody::Vector{Int};
    nfft=256, bandpass_filter=(20_000, 100_000))</code></pre><p>Plots the strength of the melody estimated by <code>findmelody</code>, in decibels.</p><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>melody</code>: result of <code>findmelody</code>.</li><li><code>nfft</code> (default: 256): window size for computing the spectrogram.</li><li><code>bandpass_filter</code> (default: <code>(20_000, 100_000)</code>): before computing the melody,   a band-pass filter is applied to the spectrogram. <code>bandpass_filter</code> is a   tuple of the (lower cutoff, upper cutoff), in Hertz.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.estimatechirp" href="#BatlabJuliaUtils.estimatechirp"><code>BatlabJuliaUtils.estimatechirp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimatechirp(chirp_seq_single_mic::ChirpSequence, peak_snr_thresh::Real;
chirp_kwargs...) -&gt; Int, Vector{Real}</code></pre><p>Use <code>estimatechirpend</code> to separate the chirp from the echos (for a single <code>ChirpSequence</code> object) by returning the chirp sequence up until the estimated end index.</p><p>Inputs:</p><ul><li><code>chirp_seq_single_mic</code>: input chirp sequence object (for a single microphone).</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>chirp_kwargs</code>: you can additionally pass in any keyword arguments for   <code>findmelody</code> and/or <code>estimate_chirp_bounds</code>.</li></ul><p>Output:</p><ul><li><code>chirp_start</code>: index of the chirp start, in samples since the beginning of   the chirp sequence.</li><li><code>chirp_est</code>: audio data of the estimated chirp.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotestimatedchirps" href="#BatlabJuliaUtils.plotestimatedchirps"><code>BatlabJuliaUtils.plotestimatedchirps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plotestimatedchirps(chirp_seq_all_mics::Dict{Int, ChirpSequence},
    peak_snr_thresh::Real; nfft=256, bandpass_filter=(20_000, 100_000),
    maximum_melody_slope=5, melody_drop_thresh_db=20,
    melody_thresh_db_low=-20, moving_avg_size=10)</code></pre><p>Plots the result of <code>estimatechirp</code>, for every microphone present in <code>chirp_seq_all_mics</code>, by plotting the estimated chirp on top of the chirp sequence.</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>same_length</code> (default: <code>true</code>): whether to zero-pad the ends of chirp   sequences so that all of them are the same length.</li><li>Rest of the arguments: see <code>estimatechirp</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.computemelodyoffsets" href="#BatlabJuliaUtils.computemelodyoffsets"><code>BatlabJuliaUtils.computemelodyoffsets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computemelodyoffsets(chirp_sequence_all_mics::Dict{Int, ChirpSequence},
    peak_snr_thresh::Real; max_offset=500, max_negative_offset=100,
    tolerance=1, chirp_kwargs...)</code></pre><p>Sometimes, especially for noisy data, the beginnings of the chirps get cut off. This function takes in data from all (high-snr) microphones for a chirp sequence and estimates how many samples were cut off from the beginning of each chirp.</p><p>It does this by:</p><ol><li>Finding the mic with the highest SNR. This mic will be used as reference.</li><li>Finding the melody and chirp lengths for each microphone.</li><li>Shifting the chirps for the non-reference microphones forward and backward  in time until we find the shift that minimizes the distance between that  chirp&#39;s melody and the reference microphone&#39;s melody.</li></ol><p>This ensures that we can &quot;align&quot; all of the chirps.</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>max_offset</code> (default: 500): maximum shift forward to try, in audio samples   (i.e., if the beginning of the chirp was cut off).</li><li><code>max_negative_offset</code> (default: 100): maximum shift backward to try, in audio   samples (i.e., if there is some noise picked up before the beginning of the   actual chirp). This should be relatively small to avoid erroneously cutting   off the beginnings of chirps.</li><li><code>tolerance</code> (default: 1): if the offset found in step 3 does not decrease the   mean absolute error of the difference between the reference melody and the   given microphone&#39;s melody by at least <code>tolerance</code>, then just set the offset   to zero.</li><li><code>chirp_kwargs</code>: you can additionally pass in any keyword arguments for   <code>findmelody</code> and/or <code>estimate_chirp_bounds</code>.</li></ul><p>Output:</p><ul><li><code>offsets</code>: dictionary mapping microphone number to the best shift, in samples   of audio data, to the number of samples cut off from the beginning of that   microphone&#39;s chirp sequence. If the number of samples is negative, this   corresponds to extra noise at the beginning of the chirp sequence.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.plotoffsetchirps" href="#BatlabJuliaUtils.plotoffsetchirps"><code>BatlabJuliaUtils.plotoffsetchirps</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function plotoffsetchirps(chirp<em>seq</em>all_mics::Dict{Int, ChirpSequence},      offsets::Dict{Int, Int})</p><p>Plot a chirp sequence, where the data from each microphone is shifted by the value found in <code>computemelodyoffsets</code>. Plots spectrograms in a vertical layout so that you can visially see if the chirps are aligned with each other.</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>offsets</code>: output of <code>computemelodyoffsets</code>.</li><li><code>start_idxs</code>: dictionary mapping microphone indices to their respective   chirp start indices (in samples since the start of the chirp sequence).   You can get this using <code>getchirpstartandendindices</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.separatechirpkwargs" href="#BatlabJuliaUtils.separatechirpkwargs"><code>BatlabJuliaUtils.separatechirpkwargs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">separatechirpkwargs(;chirp_kwargs...) -&gt; Dict{Symbol, Any},  
                                         Dict{Symbol, Any},
                                         Dict{Symbol, Any}</code></pre><p>Given keyword arguments from a combination of <code>findmelody</code>, <code>estimatechirpbounds</code>, and <code>computemelodyoffsets</code>, separate them into  three dictionaries: one for each of those functions.</p></div></section></article><h1 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h1><p>This section contains helper methods for performing blind deconvolution on a chirp sequence to estimate the initial bat vocalization.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.colwisenormalize" href="#BatlabJuliaUtils.colwisenormalize"><code>BatlabJuliaUtils.colwisenormalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">colwisenormalize(Y::Matrix) -&gt; Matrix</code></pre><p>Normalizes each column of matrix <code>Y</code> such that each column has an amplitude (i.e., maximum absolute value) of 1.</p><p>Inputs:</p><ul><li><code>Y</code>: matrix, where each column is a different channel of data.</li></ul><p>Outputs:</p><ul><li><code>Y</code>, with each column divided by its amplitude.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getchirpsequenceY" href="#BatlabJuliaUtils.getchirpsequenceY"><code>BatlabJuliaUtils.getchirpsequenceY</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getchirpsequenceY(chirp_seq_all_mics::Dict{Int, ChirpSequence},
    offsets::Dict{Int, Int}, pad_len::Int; normalize=true)
                                    -&gt; Matrix{Real}, Vector{Int}</code></pre><p>Given chirp sequence objects (for all microphones) corresponding to the same initial vocalization, produce a matrix of microphone data, where each column is a different microphone. The microphone data is zero-padded at the beginning and the end by <code>pad_len</code> zeros. In addition, if the beginning of any chirp was cut off (as determined by <code>offsets</code>, which is the output of <code>computemelodyoffsets</code>), the beginning is zero-padded by the number of samples that were cut off. By default, each column of the output is normalized to have amplitude 1.</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>offsets</code>: output of <code>computemelodyoffsets</code>; mapping of microphone index to   how many samples were cut off (if any) at the beginning of the chirp.</li><li><code>pad_len</code>: how many zeros to add to the beginning and end of the mic data.   This is used to mitigate edge effects from circular convolution.</li><li><code>normalize</code> (default: <code>true</code>): whether to ensure each column of the output   has amplitude <code>1</code>.</li></ul><p>Outputs:</p><ul><li><code>Y</code>: L x K matrix, where L is the length of the longest chirp sequene in   <code>chirp_seq_all_mics</code>, plus <code>2*pad_len</code> and <code>K</code> is the number of   microphones used.</li><li><code>mics</code>: list of microphone number, where the microphone number at each index   is the microphone used for the corresponding column of <code>Y</code>.</li></ul></div></section><section><div><pre><code class="language-julia hljs">getchirpsequenceY(chirp_seq_all_mics::Dict{Int, ChirpSequence},
    peak_snr_thresh::Real, pad_len::Int; normalize=true,
    offset_kwargs...) -&gt; Matrix{Real}, Vector{Int}</code></pre><p>Like the above function (<code>getchirpsequenceY(chirp_seq_all_mics, offsets, pad_len, normalize)</code>), except the <code>offsets</code> are automatically computed using <code>computemelodyoffsets</code>.</p><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>pad_len</code>: how many zeros to add to the beginning and end of the mic data.   This is used to mitigate edge effects from circular convolution.</li><li><code>normalize</code> (default: <code>true</code>): whether to ensure each column of the output   has amplitude <code>1</code>.</li><li><code>offset_kwargs</code>: optionally, you can pass in any keyword arguments for   <code>computemelodyoffsets</code>.</li></ul><p>Outputs:</p><ul><li><code>Y</code>: L x K matrix, where L is the length of the longest chirp sequene in   <code>chirp_seq_all_mics</code>, plus <code>2*pad_len</code> and <code>K</code> is the number of   microphones used.</li><li><code>mics</code>: list of microphone number, where the microphone number at each index   is the microphone used for the corresponding column of <code>Y</code>.</li></ul></div></section><section><div><pre><code class="language-julia hljs">getchirpsequenceY(chirp_seq_all_mics::Dict{Int, ChirpSequence},
    pad_len::Int; normalize=true) -&gt; Matrix{Real}, Vector{Int}</code></pre><p>Like the above function (<code>getchirpsequenceY(chirp_seq_all_mics, offsets, pad_len, normalize)</code>), except the <code>offsets</code> are all set to zero.</p><p>Inputs</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>pad_len</code>: how many zeros to add to the beginning and end of the mic data.   This is used to mitigate edge effects from circular convolution.</li><li><code>normalize</code> (default: <code>true</code>): whether to ensure each column of the output   has amplitude <code>1</code>.</li></ul><p>Outputs:</p><ul><li><code>Y</code>: L x K matrix, where L is the length of the longest chirp sequene in   <code>chirp_seq_all_mics</code>, plus <code>2*pad_len</code> and <code>K</code> is the number of   microphones used.</li><li><code>mics</code>: list of microphone number, where the microphone number at each index   is the microphone used for the corresponding column of <code>Y</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getinitialconditionsnr" href="#BatlabJuliaUtils.getinitialconditionsnr"><code>BatlabJuliaUtils.getinitialconditionsnr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getinitialconditionsnr(Y::AbstractArray,
    chirp_seq_all_mics::Dict{Int, ChirpSequence}, mics::Vector{Int},
    peak_snr_thresh::Real; h_fft_thresh=0.1, nfft=256, chirp_kwargs...) 
                                -&gt; Vector{Real}, Matrix{Real}, Int</code></pre><p>Produces an initial condition for the blind deconvolution algorithm (i.e.: an estimate of the bat chirp and the impulse responses mapping the bat chirp to the audio output of each microphone). It uses the chirp estimate (from  <code>estimatechirp</code>) for the highest-SNR microphone as the estimate of the bat chirp, and performs Fourier deconvolution (see the <code>deconvolve</code> function) to get the impulse responses.</p><p>This is the preferred method of obtaining the initial condition for noisy data.</p><p>Inputs:</p><ul><li><code>Y</code>: matrix of audio data, produced by <code>getchirpsequenceY</code>.</li><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>mics</code>: list of microphones used, produced by <code>getchirpsequenceY</code>.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>h_fft_thresh</code> (default: 0.1): the Fourier transform of <code>H_init</code> is set to   zero at indices where the FFT of <code>X_init</code> is below this threshold.</li><li><code>nfft</code>: window size of the STFT used to get the melody.</li><li><code>chirp_kwargs</code>: you can pass in any keywords for <code>estimatechirp</code>.</li></ul><p>Outputs: </p><ul><li><code>X_init</code>: estimated bat vocalization.</li><li><code>H_init</code>: matrix of estimated impulse responses, the k-th column of <code>H_init</code>,   convolved with <code>X_init</code>, produces the k-th column of <code>Y</code>.</li><li><code>longest_chirp</code>: length of the longest estimated chirp.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getinitialconditionsparsity" href="#BatlabJuliaUtils.getinitialconditionsparsity"><code>BatlabJuliaUtils.getinitialconditionsparsity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getinitialconditionsparsity(Y::Matrix{Real},
    chirp_seq_all_mics::Dict{Int, ChirpSequence}, mics::Vector{Int},
    peak_snr_thresh::Real; h_fft_thresh=0.1, nfft=256, chirp_kwargs...) 
                                -&gt; Vector{Real}, Matrix{Real}, Int</code></pre><p>Produces an initial condition for the blind deconvolution algorithm (i.e.: an estimate of the bat chirp and the impulse responses mapping the bat chirp to the audio output of each microphone). It uses the chirp estimate (from  <code>estimatechirp</code>) for one of the microphones as the estimate of the bat chirp, and performs Fourier deconvolution (see the <code>deconvolve</code> function) to get the impulse responses. The chirp is estimated using whichever microphone produces the sparserst impulse response.</p><p>This is not recommended for noisy data; <code>getinitialconditionsnr</code> is better for that case.</p><p>Inputs:</p><ul><li><code>Y</code>: matrix of audio data, produced by <code>getchirpsequenceY</code>.</li><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>mics</code>: list of microphones used, produced by <code>getchirpsequenceY</code>.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>h_fft_thresh</code> (default: 0.1): the Fourier transform of <code>H_init</code> is set to   zero at indices where the FFT of <code>X_init</code> is below this threshold.</li><li><code>nfft</code>: window size of the STFT used to get the melody.</li><li><code>chirp_kwargs</code>: you can pass in any keywords for <code>estimatechirp</code>.</li></ul><p>Outputs: </p><ul><li><code>X_init</code>: estimated bat vocalization. <code>nfft/2</code></li><li><code>H_init</code>: matrix of estimated impulse responses, the k-th column of <code>H_init</code>,   convolved with <code>X_init</code>, produces the k-th column of <code>Y</code>.</li><li><code>longest_chirp</code>: length of the longest estimated chirp.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.getmelodyregularization" href="#BatlabJuliaUtils.getmelodyregularization"><code>BatlabJuliaUtils.getmelodyregularization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function getmelodyregularization(chirp<em>seq</em>all<em>mics::Dict{Int, ChirpSequence},     N::Int, peak</em>snr<em>thresh::Real; melody</em>radius = 2, nfft=256,     stft<em>stride=Int(floor(nfft/4)), max</em>freq<em>hz=100</em>000, chirp_kwargs...)                                                                     -&gt; Matrix</p><p>Produces a weight matrix (of the same dimensions of the STFT of a bat vocalization, where the length of the vocalization is length of the longest estimated chirp for <code>chirp_seq_all_mics</code>) that quantifies how far any part of the spectrogram is from the melody or one of its harmonics.</p><p>Details of the algorithm are as follows:</p><ol><li><p>Initialize <code>Mx2</code>, the element-wise square of the weight matrix, to be all  infinity.</p></li><li><p>For each microphone in <code>chirp_seq_all_mics</code>:  -Find the melody, chirp start/end indices, and whether the beginning of      the chirp was cut off.</p><ul><li><p>Loop through all harmonics under <code>max_freq_hz</code>:</p><ul><li><p>Find the distance of each point on the spectrogram to some range   around the melody. The radius of this range is either,   <code>melody_radius</code>, which is found by linearly interpolating   <code>melody_radius_start</code> and <code>melody_radius_end</code>,   or the slope of the melody at the given point, whichever is larger.</p><p>This provides some leeway in where the actual melody falls, where the leeway is determined by how fast the melody is changing.</p></li><li><p>Set <code>Mx2</code> to the element-wise minimum of its current value and the   squared distance from step i.</p></li></ul></li></ul></li><li><p>Truncate <code>Mx2</code> to the maximum estimated chirp length.</p></li><li><p>Downsample <code>Mx2</code> by a factor of <code>stft_stride</code>, setting each index of the  downsampled version to the minimum value in a time radius of <code>nfft/2</code>.</p></li></ol><p>Inputs:</p><ul><li><code>chirp_seq_all_mics</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>N</code>: upper bound on the length of the bat vocalization.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>melody_radius_start</code>, <code>melody_radius_end</code> (defaults: 6, 1): described in step 2.b.i above.</li><li><code>nfft</code> (default: 256): window length to use for the STFT.</li><li><code>stft_stride</code> (default: <code>nfft/4</code>): amount to downsample in step 4 above.</li><li><code>max_freq_hz</code> (default: 100k): used to find the highest possible harmonic.</li><li><code>chirp_kwargs</code>: optionally, you can pass in any keyward arguments for   <code>findmelody</code>, <code>estimatechirpbounds</code>, <code>computemelodyoffsets</code>, or   <code>getmelodyregularization</code>. See those functions for more detauls</li></ul><p>Outputs:</p><ul><li><code>Mx2</code>: weight matrix, described above.</li><li><code>max_chirp_len</code>: maximum chirp length from <code>estimatechirp</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.optimizePALM" href="#BatlabJuliaUtils.optimizePALM"><code>BatlabJuliaUtils.optimizePALM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimizePALM(chirp_seq::Dict{Int, ChirpSequence}, Y::Matrix{Real}, 
    H_init::Matrix{Real}, X_init::Array{Real}, peak_snr_thresh::Real,
    data_fitting_weight::Real, sparsity_weight::Real, melody_weight::Real;
    max_iter=1000, alpha=1e-3, gamma_H=1, gamma_X=1, num_debug=10, nfft=256,
    stft_stride=Int(floor(nfft/4)), chirp_kwargs...) -&gt; Matrix, Matrix, Int</code></pre><p>Performs blind deconvolution, formulated as an optimization problem with a combination of the following objectives:</p><ol><li>Data-fitting: making sure <code>X</code>, convolved with any column of <code>H</code>, the matrix  of impulse responses, is close to the corresponding column of <code>Y</code>, the  microphone data marix produced by <code>getchirpsequenceY</code>.</li><li>Impulse response sparsity: encouraging sparsity of <code>H</code>, measured by the  absolute sum (L1 norm) of the elements of <code>H</code>.</li><li>Melody following: making sure the energy of the spectrogram  of <code>X</code> is close  to the melody or one of its harmonics. See <code>getmelodyregularization</code> for  more details.</li></ol><p>This optimization problem is solved using PALM (proximal alternating linearized optimization: <a href="https://arxiv.org/abs/1604.00526">paper</a>), following the general process outlined in <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7730569/">this paper</a>.</p><p>Inputs:</p><ul><li><code>chirp_seq</code>: mapping of microphone index to <code>ChirpSequence</code> object.</li><li><code>Y</code>: matrix of microphone data; output of <code>getchirpsequenceY</code>.</li><li><code>H_init</code>: initial condition for the impulse responses; output of   <code>getinitialconditionsnr</code> or <code>getinitialconditionsparsity</code>.</li><li><code>X_init</code>: initial condition for the bat vocalization. Produced by the same   function as <code>H_init</code>.</li><li><code>peak_snr_thresh</code>: threshold set for the peak SNR of a chirp sequence.</li><li><code>data_fitting_weight</code>: weight of the data-fitting term in the optimization   objective. Can be thought of as a percentage of how much that term   matters (60 is a generally good value).</li><li><code>sparsity_weight</code>: weight of the sparsity term in the objective. 10 is a   generally good value.</li><li><code>melody_weight</code>: weight of the melody-following term in the objective. 50 is   a generally good value.</li><li><code>max_iter</code> (default: 1000): number of iterations to run the algorithm for.</li><li><code>alpha</code> (default: 0.001): the absolute sum of the elements of <code>H</code> is   approximated using the smooth function <code>|x| ≈ sqrt(x^2 + alpha^2) - alpha</code>,   where <code>alpha</code> is some small number</li><li><code>gamma_H</code> (default: 1): factor to slow down updates of <code>H</code> (must be at least   1, or the algorithm might not converge).</li><li><code>gamma_X</code> (default: 1): factor to slow down updates of <code>X</code> (must be at least   1, or the algorithm might not converge).</li><li><code>num_debug</code> (default: 10): number of times to print debug statements over the   course of the optimization algorithm.</li><li><code>nfft</code> (default: 256): window length to use for the spectrogram of <code>X</code>.</li><li><code>stft_stride</code> (default: <code>nfft/4</code>): spacing between adjacent spectrogram   windows.</li><li><code>chirp_kwargs</code>: optionally, you can pass in any keyward arguments for   <code>findmelody</code>, <code>estimatechirpbounds</code>, or <code>computemelodyoffsets</code>.</li></ul><p>Outputs:</p><ul><li><code>X</code>: bat vocalization, as estimated by the optimization algorithm,</li><li><code>H</code>: matrix of impulse responses, as estimated by the optimization algorithm.</li><li><code>max_chirp_len</code>: maximum chirp length from <code>estimatechirp</code>.</li></ul></div></section></article><h1 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.matrixtovector" href="#BatlabJuliaUtils.matrixtovector"><code>BatlabJuliaUtils.matrixtovector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrixtovector(mat::AbstractArray)</code></pre><p>Given an input matrix, return the vector produced by stacking all of the columns together. If the input is already a vector, it remains unchanged.</p><p>Inputs:</p><ul><li><code>mat</code>: matrix to transform to a vector.</li></ul><p>Output:</p><ul><li><code>vec</code>: e.g., if <code>mat</code> is <code>[1 2 3; 4 5 6]</code>, vec will be <code>[1, 4, 2, 5, 3, 6]</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.vectortomatrix" href="#BatlabJuliaUtils.vectortomatrix"><code>BatlabJuliaUtils.vectortomatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vectortomatrix(vec::AbstractArray)</code></pre><p>Given an input vector, return a matrix that consists of one column. If the input is already a matrix, it remains unchanged.</p><p>Inputs:</p><ul><li><code>vec</code>: vector to transform to a one-column matrix.</li></ul><p>Output:</p><ul><li><code>mat</code>: single-column matrix.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.randint" href="#BatlabJuliaUtils.randint"><code>BatlabJuliaUtils.randint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randint(end_idx::Int) -&gt; Int</code></pre><p>Returns a random integer from 1 to <code>end_idx</code>, inclusive.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BatlabJuliaUtils.distancefrommic" href="#BatlabJuliaUtils.distancefrommic"><code>BatlabJuliaUtils.distancefrommic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distancefrommic(location_data::Vector{Real},
    mic_positions::Matrix{Real}, mic_num::Int) -&gt; Real</code></pre><p>Given one frame of centroid data, compute the distance from mic <code>mic_num</code>.</p><p>Inputs:</p><ul><li><code>location_data</code>: one frame of centroid data, as a vector.</li><li><code>mic_positions</code>: matrix of microphone positions, where each row is a   different microphone and the columns represent coordinates (x, y, z).</li><li><code>mic_num</code>: microphone for which to compute distances.</li></ul><p>Output: distance from mic <code>mic_num</code>.</p></div></section><section><div><pre><code class="language-julia hljs">distancefrommic(location_data::Matrix{Real},
    mic_positions::Matrix{Real}, mic_num::Int) -&gt; Vector{Real}</code></pre><p>Given centroid data for multiple time points, compute the distance from mic <code>mic_num</code> (for each time point).</p><p>Inputs:</p><ul><li><code>location_data</code>: slice of centroid data, where the columns represent   coordinates (x, y, z).</li><li><code>mic_positions</code>: matrix of microphone positions, where each row is a   different microphone and the columns represent coordinates (x, y, z).</li><li><code>mic_num</code>: microphone for which to compute distances.</li></ul><p>Output: vector of distance from mic <code>mic_num</code>, for each row of <code>location_data</code>.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Wednesday 27 December 2023 18:32">Wednesday 27 December 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
